# -*- coding: utf-8 -*-
"""Untitled6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1A5TIXB6Aocl9Enyg7RUWO4nKj_PIM4RF
"""

# ------------------------------------------------------------
# Lab Report BSD3513 ‚Äì Artificial Intelligence
# Chapter 2: Search Algorithms (BFS & DFS)
# Student Name: AHMAD DHANI BIN NORMANN ARBAQ
# Student ID: SD23051
# Section: 02G
# ------------------------------------------------------------

import streamlit as st
from collections import deque
from PIL import Image

# ------------------------------------------------------------
# Streamlit App Header
# ------------------------------------------------------------
st.set_page_config(page_title="BFS & DFS Visualizer", layout="centered")
st.title("üîç BFS and DFS Graph Traversal Visualizer")
st.markdown("### BSD3513 ‚Äì Lab Report 1")
st.markdown("*Name:* AHMAD DHANI BIN NORMANN ARBAQ | *Student ID:* SD23051 | *Section:* 02G")

# ------------------------------------------------------------
# Display single image at the top
# ------------------------------------------------------------
st.subheader("Graph Reference Image")
st.info("Below is the sample graph used for BFS and DFS traversal demonstrations.")

# Robust image loading: look in the script directory for common filenames and fall back to a generated placeholder
from pathlib import Path
from PIL import ImageDraw, ImageFont

script_dir = Path(__file__).parent
candidates = [
    "LabReport_BSD2513_#1.jpg"
]

img_path = None
for name in candidates:
    p = script_dir / name
    if p.exists():
        img_path = p
        break

if img_path is not None:
    try:
        image = Image.open(img_path)
        st.image(image, caption=f"Graph used for BFS and DFS Traversal ({img_path.name})", use_column_width=True)
    except Exception:
        st.warning(f"‚ö† Found '{img_path.name}' but failed to open it. It may be corrupted.")
else:
    # Generate a simple placeholder image so the app still looks complete
    W, H = 800, 400
    placeholder = Image.new("RGB", (W, H), color=(255, 255, 255))
    draw = ImageDraw.Draw(placeholder)
    try:
        font = ImageFont.load_default()
    except Exception:
        font = None
    text = "Image not found\nPlace a graph image (e.g. BFS_img1.jpg) in this folder"
    # center text
    lines = text.split("\n")
    y_text = 120
    for line in lines:
        w, h = draw.textsize(line, font=font)
        draw.text(((W - w) / 2, y_text), line, fill=(0, 0, 0), font=font)
        y_text += h + 6
    st.image(placeholder, caption="(Placeholder) Graph image not found", use_column_width=True)

# ------------------------------------------------------------
# Graph Definition
# ------------------------------------------------------------
graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['F'],
    'F': []
}

st.subheader("1. Graph Structure")
st.json(graph)

# Make traversal deterministic by sorting neighbor lists alphabetically
for node in graph:
    try:
        graph[node] = sorted(graph[node])
    except Exception:
        # In case the adjacency is not iterable or missing, leave it as-is
        pass

# ------------------------------------------------------------
# BFS Implementation
# ------------------------------------------------------------
def bfs(graph, start_node):
    visited = []
    queue = deque([start_node])
    order = []

    while queue:
        s = queue.popleft()
        if s not in visited:
            visited.append(s)
            order.append(s)
            for neighbour in graph[s]:
                if neighbour not in visited and neighbour not in queue:
                    queue.append(neighbour)
    return order


# ------------------------------------------------------------
# DFS Implementation
# ------------------------------------------------------------
def dfs(graph, start_node, visited=None, order=None):
    if visited is None:
        visited = set()
        order = []
    if start_node not in visited:
        visited.add(start_node)
        order.append(start_node)
        for neighbour in graph[start_node]:
            dfs(graph, neighbour, visited, order)
    return order


# ------------------------------------------------------------
# Streamlit Interface for Running Algorithms
# ------------------------------------------------------------
st.subheader("2. Choose Traversal Type")
start_node = st.selectbox("Select Starting Node:", list(graph.keys()))
algorithm = st.radio("Choose Algorithm:", ["Breadth-First Search (BFS)", "Depth-First Search (DFS)"])

if st.button("Run Traversal"):
    # Validate start node
    if start_node not in graph:
        st.error(f"Start node '{start_node}' is not present in the graph. Choose a valid node.")
    else:
        if algorithm == "Breadth-First Search (BFS)":
            result = bfs(graph, start_node)
            st.success("Traversal Order (BFS): " + " ‚Üí ".join(result))
        else:
            result = dfs(graph, start_node)
            st.success("Traversal Order (DFS): " + " ‚Üí ".join(result))

        st.markdown("*Visited Nodes Order:*")
        st.code(", ".join(result))

# ------------------------------------------------------------
# Explanation Section
# ------------------------------------------------------------
st.markdown("---")
st.subheader("3. Algorithm Explanation")

st.markdown("""
*Breadth-First Search (BFS)*
- Explores all neighbors level by level before moving deeper.
- Uses a *queue* (FIFO order).
- Example: A ‚Üí B ‚Üí C ‚Üí D ‚Üí E ‚Üí F

*Depth-First Search (DFS)*
- Explores as far as possible down one branch before backtracking.
- Uses a *stack* (implicit recursion).
- Example: A ‚Üí B ‚Üí D ‚Üí E ‚Üí F ‚Üí C
""")

st.markdown("### üìò Complexity Summary")
st.table({
    "Algorithm": ["BFS", "DFS"],
    "Time Complexity": ["O(V + E)", "O(V + E)"],
    "Space Complexity": ["O(V)", "O(V)"]
})

st.markdown("---")
st.caption("Developed with Streamlit for BSD3513 Lab Report 1 ‚Äì AI Search Algorithms.")